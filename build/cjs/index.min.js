"use strict";
/**
 * 画像処理用の色を表す基底クラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class t{constructor(){}getColor(){return null}clone(){return null}zero(){return null}one(){return null}add(t){return null}sub(t){return null}mul(t){return null}div(t){return null}exp(){return null}log(){return null}pow(t){return null}baselog(t){return null}table(t){return null}random(){return null}luminance(){return null}addColor(t){return null}subColor(t){return null}mulColor(t){return null}divColor(t){return null}maxColor(t){return null}minColor(t){return null}norm(t){return null}normFast(t){return null}normColor(t,e){return this.subColor(t).norm(e)}normColorFast(t,e){return this.subColor(t).normFast(e)}getBlendAlpha(){return null}setBlendAlpha(t){return null}exchangeColorAlpha(t){return null}equals(t){return!1}searchColor(t,e){let i=0,r=2147483647,n=null,h=2147483646,s=null;for(let o=0;o<t.length;o++)i=this.normColorFast(t[o],e),i<h&&(i<r?(h=r,s=n,r=i,n=t[o]):(h=i,s=t[o]));return{c1:{color:n,norm:r},c2:{color:s,norm:h}}}}t.NORM_MODE={MANHATTEN:0,EUGRID:1};
/**
 * 画像処理用のブレンドモードを管理するクラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
const e={ipLerp:function(t,e,i){const r=e.subColor(t);return t.addColor(r.mul(i))},brendNone:function(t,e,i){return e},brendAlpha:function(t,i,r){const n=t.getBlendAlpha(),h=i.getBlendAlpha()*r;return(t=e.ipLerp(t,i,h)).setBlendAlpha(Math.max(n,h))},brendAdd:function(t,e,i){const r=t.getBlendAlpha(),n=e.getBlendAlpha()*i;return(t=t.addColor(e.mul(n))).setBlendAlpha(Math.max(r,n))},brendSub:function(t,e,i){const r=t.getBlendAlpha(),n=e.getBlendAlpha()*i;return(t=t.subColor(e.mul(n))).setBlendAlpha(r)},brendRevSub:function(t,e,i){const r=e.getBlendAlpha(),n=t.getBlendAlpha()*i;return(e=e.subColor(t.mul(n))).setBlendAlpha(r)},brendMul:function(t,e,i){const r=t.getBlendAlpha(),n=e.getBlendAlpha()*i;return(t=t.mulColor(e.mul(n).div(255))).setBlendAlpha(r)}};class i{constructor(t){this.blendfunc=e.brendNone,1===arguments.length&&this.setBlendMode(t)}clone(){return new i(this.blendmode)}setBlendMode(t){this.blendmode=t,t===i.MODE.NONE?this.blendfunc=e.brendNone:t===i.MODE.ALPHA?this.blendfunc=e.brendAlpha:t===i.MODE.ADD?this.blendfunc=e.brendAdd:t===i.MODE.SUB?this.blendfunc=e.brendSub:t===i.MODE.REVSUB?this.blendfunc=e.brendRevSub:t===i.MODE.MUL&&(this.blendfunc=e.brendMul)}blend(t,e,i){return this.blendfunc(t,e,i)}}i.MODE={NONE:"NONE",ALPHA:"ALPHA",ADD:"ADD",SUB:"SUB",REVSUB:"REVSUB",MUL:"MUL"};
/**
 * 画像座標のラッピング（境界判定）用のクラス（範囲内のみ許可）
 * 画像の端から外にはみ出した場合に「範囲内ならそのまま／範囲外ならnull」を返す
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
class r{constructor(t,e){2===arguments.length?this.setSize(t,e):this.setSize(0,0)}clone(){return new r(this.width,this.height)}setSize(t,e){this.width=t,this.height=e}getPixelPosition(t,e){return t=Math.floor(t),e=Math.floor(e),t>=0&&e>=0&&t<this.width&&e<this.height?[t,e]:null}}
/**
 * 画像座標のラッピング（はみ出し時は端にクランプする方式）
 * 画像の外側を参照した場合、座標を強制的に最も近い端にクランプして返す
 *
 * @module PixWrapClamp
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class n extends r{constructor(t,e){super(t,e)}clone(){return new n(this.width,this.height)}getPixelPosition(t,e){return t=Math.floor(t),e=Math.floor(e),t>=0&&e>=0&&t<this.width&&e<this.height?[t,e]:[t=Math.floor(Math.min(Math.max(0,t),this.width-1)),e=Math.floor(Math.min(Math.max(0,e),this.height-1))]}}
/**
 * 画像座標のラッピング（範囲外は繰り返しリピートする方式）
 * 範囲外座標は画像サイズでラップ（繰り返し）されます。
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class h extends r{constructor(t,e){super(t,e)}clone(){return new h(this.width,this.height)}getPixelPosition(t,e){if(t=Math.floor(t),e=Math.floor(e),t>=0&&e>=0&&t<this.width&&e<this.height)return[t,e];const i=Math.floor(t/this.width),r=Math.floor(e/this.height);return t-=Math.floor(this.width*i),e-=Math.floor(this.height*r),t<0&&(t+=this.width),e<0&&(e+=this.height),[t,e]}}
/**
 * 画像座標ラッピングの切り替え管理クラス
 * 指定モードごとに、範囲外座標の振る舞い（inside, clamp, repeat）を動的に切り替える基底クラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class s{constructor(t,e,i){this.width=1,this.height=1,arguments.length>=2&&(this.width=e,this.height=i),3==arguments.length?this.setPixWrapMode(t):this.setPixWrapMode(s.MODE.INSIDE)}clone(){return new s(this.wrapmode,this.width,this.height)}setPixWrapMode(t){this.wrapmode=t,t===s.MODE.INSIDE?this.wrap=new r(this.width,this.height):t===s.MODE.CLAMP?this.wrap=new n(this.width,this.height):t===s.MODE.REPEAT&&(this.wrap=new h(this.width,this.height))}setSize(t,e){this.width=t,this.height=e,this.wrap&&this.wrap.setSize(t,e)}getPixelPosition(t,e){return this.wrap.getPixelPosition(t,e)}}s.MODE={INSIDE:"INSIDE",CLAMP:"CLAMP",REPEAT:"REPEAT"};
/**
 * 補間モード・関数群をまとめたクラス
 * 画像内の任意座標の色を求めるための補間手法を実装
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
const o={ipLerp:function(t,e,i){const r=e.subColor(t);return t.addColor(r.mul(i))},ipCosine:function(t,e,i){return o.ipLerp(t,e,.5*(1-Math.cos(Math.PI*i)))},ipHermite2p3:function(t,e,i){return o.ipLerp(t,e,i*i*(3-2*i))},ipHermite2p5:function(t,e,i){return o.ipLerp(t,e,i*i*i*(6*i*i-15*i+10))},ipHermite4p:function(t,e,i,r,n){const h=r.subColor(i).subColor(t.subColor(e)),s=t.subColor(e).subColor(h),o=i.subColor(t),l=e;return h.mul(n*n*n).addColor(s.mul(n*n)).addColor(o.mul(n)).addColor(l)},funcInBicubic:function(t,e){return t<=1?1-(e+3)*t*t+(e+2)*t*t*t:-4*e+8*e*t-5*e*t*t+e*t*t*t},ipBicubic:function(t,e,i,r,n,h){const s=o.funcInBicubic(n+1,h),l=o.funcInBicubic(n,h),a=o.funcInBicubic(1-n,h),u=o.funcInBicubic(2-n,h);return t.mul(s).addColor(e.mul(l)).addColor(i.mul(a)).addColor(r.mul(u)).mul(1/(s+l+a+u))},ipBicubicSoft:function(t,e,i,r,n){return o.ipBicubic(t,e,i,r,n,-.5)},ipBicubicNormal:function(t,e,i,r,n){return o.ipBicubic(t,e,i,r,n,-1)},ipBicubicSharp:function(t,e,i,r,n){return o.ipBicubic(t,e,i,r,n,-1.2)},ipBicubic2D:function(t,e,i,r){let n,h,s,l,a=t[0][0].zero(),u=0;for(h=0;h<4;h++)for(s=o.funcInBicubic(Math.abs(-i+h-1),r),n=0;n<4;n++)l=o.funcInBicubic(Math.abs(-e+n-1),r),l*=s,u+=l,a=a.addColor(t[h][n].mul(l));return a=a.mul(1/u),a},ipBicubic2DSoft:function(t,e,i){return o.ipBicubic2D(t,e,i,-.5)},ipBicubic2DNormal:function(t,e,i){return o.ipBicubic2D(t,e,i,-1)},ipBicubic2DSharp:function(t,e,i){return o.ipBicubic2D(t,e,i,-1.2)}};class l{constructor(t){0===arguments.length&&(t=l.MODE.NEAREST_NEIGHBOR),this.ipmode=null,this.ipn=0,this.ipfunc=null,this.setInterpolationMode(t)}clone(){return new l(this.ipmode)}setInterpolationMode(t){this.ipmode=t,t===l.MODE.NEAREST_NEIGHBOR?(this.ipfunc=o.ipLerp,this.ipn=1):t===l.MODE.BILINEAR?(this.ipfunc=o.ipLerp,this.ipn=2):t===l.MODE.COSINE?(this.ipfunc=o.ipCosine,this.ipn=2):t===l.MODE.HERMITE4_3?(this.ipfunc=o.ipHermite2p3,this.ipn=2):t===l.MODE.HERMITE4_5?(this.ipfunc=o.ipHermite2p5,this.ipn=2):t===l.MODE.HERMITE16?(this.ipfunc=o.ipHermite4p,this.ipn=4):t===l.MODE.BICUBIC?(this.ipfunc=o.ipBicubic2DNormal,this.ipn=16):t===l.MODE.BICUBIC_SOFT?(this.ipfunc=o.ipBicubicSoft,this.ipn=4):t===l.MODE.BICUBIC_NORMAL?(this.ipfunc=o.ipBicubicNormal,this.ipn=4):t===l.MODE.BICUBIC_SHARP&&(this.ipfunc=o.ipBicubicSharp,this.ipn=4)}getColor(t,e,i){const r=Math.floor(e),n=Math.floor(i);if(1===this.ipn||r===e&&n===i)return t.getPixel(r,n);if(2===this.ipn){const h=e-r,s=i-n;let o,l;o=t.getPixel(r,n),l=t.getPixel(r+1,n);const a=this.ipfunc(o,l,h);o=t.getPixel(r,n+1),l=t.getPixel(r+1,n+1);const u=this.ipfunc(o,l,h);return this.ipfunc(a,u,s)}if(4===this.ipn){const h=e-r,s=i-n;let o,l,a,u;o=t.getPixel(r-1,n-1),l=t.getPixel(r,n-1),a=t.getPixel(r+1,n-1),u=t.getPixel(r+2,n-1);const c=this.ipfunc(o,l,a,u,h);o=t.getPixel(r-1,n),l=t.getPixel(r,n),a=t.getPixel(r+1,n),u=t.getPixel(r+2,n);const g=this.ipfunc(o,l,a,u,h);o=t.getPixel(r-1,n+1),l=t.getPixel(r,n+1),a=t.getPixel(r+1,n+1),u=t.getPixel(r+2,n+1);const d=this.ipfunc(o,l,a,u,h);o=t.getPixel(r-1,n+2),l=t.getPixel(r,n+2),a=t.getPixel(r+1,n+2),u=t.getPixel(r+2,n+2);const p=this.ipfunc(o,l,a,u,h);return this.ipfunc(c,g,d,p,s)}if(16===this.ipn){const h=e-r,s=i-n;let o,l;const a=[];for(l=-1;l<3;l++){const e=[];for(o=-1;o<3;o++)e[e.length]=t.getPixel(r+o,n+l);a[a.length]=e}return this.ipfunc(a,h,s)}return null}}l.MODE={NEAREST_NEIGHBOR:"NEAREST_NEIGHBOR",BILINEAR:"BILINEAR",COSINE:"COSINE",HERMITE4_3:"HERMITE4_3",HERMITE4_5:"HERMITE4_5",HERMITE16:"HERMITE16",BICUBIC:"BICUBIC",BICUBIC_SOFT:"BICUBIC_SOFT",BICUBIC_NORMAL:"BICUBIC_NORMAL",BICUBIC_SHARP:"BICUBIC_SHARP"};
/**
 * 画像処理用のFIR（畳み込み）フィルタ行列クラス
 * ブラーやシャープ、ガウシアンなど各種フィルタの行列生成・操作に使用
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
class a{constructor(t){let e;for(this.height=t.length,this.width=t[0].length,this.matrix=[],e=0;e<t.length;e++)this.matrix[e]=t[e].slice()}clone(){return new a(this.matrix)}rotateEdge(t){const e=this.clone(),i=[],r=[];let n,h;for(n=0;n<this.width-1;n++)i.push(e.matrix[0][n]);for(n=0;n<this.height-1;n++)i.push(e.matrix[n][this.width-1]);for(n=this.width-1;n>0;n--)i.push(e.matrix[this.height-1][n]);for(n=this.height-1;n>0;n--)i.push(e.matrix[n][0]);for(n=0;n<i.length;n++)r[n]=i[((n+t)%i.length+i.length)%i.length];for(e.matrix[0]=r.slice(0,this.width),n=0;n<this.height;n++)e.matrix[n][this.width-1]=r[this.width+n];for(e.matrix[this.height-1]=r.slice(this.width+this.height-2,this.width+this.height-2+this.width).reverse(),n=this.height-1,h=0;n>0;n--,h++)e.matrix[n][0]=r[this.width+this.height+this.width-3+h];return e}mul(t){const e=this.clone();let i,r;for(r=0;r<e.height;r++)for(i=0;i<e.width;i++)e.matrix[r][i]*=t;return e}sum(){let t,e,i=0;for(e=0;e<this.height;e++)for(t=0;t<this.width;t++)i+=this.matrix[e][t];return i}normalize(){return this.clone().mul(1/this.sum())}addCenter(t){const e=this.clone();return e.matrix[e.height>>1][e.width>>1]+=t,e}static makeLaplacianFilter(){return new a([[0,-1,0],[-1,4,-1],[0,-1,0]])}static makeSharpenFilter(t){return a.makeLaplacianFilter().mul(t).addCenter(1)}static makeBlur(t,e){const i=[],r=1/(t*e);let n,h;for(h=0;h<e;h++)for(i[h]=[],n=0;n<t;n++)i[h][n]=r;return new a(i)}static makeGaussianFilter(t,e,i){void 0===i&&(i=1);const r=[];let n,h,s;const o=[],l=Math.max(t,e);let u=-Math.floor(l/2);for(n=0;n<l;n++,u++)o[n]=Math.exp(-u*u/(i*i*2));for(s=0;s<e;s++)for(r[s]=[],h=0;h<t;h++)r[s][h]=o[h]*o[s];return new a(r).normalize()}static makeCircle(t){const e=[],i=.5*t,r=t>>1;let n,h;for(h=0;h<t;h++)for(e[h]=[],n=0;n<t;n++)Math.sqrt((r-n)*(r-n)+(r-h)*(r-h))<i?e[h][n]=1:e[h][n]=0;return new a(e).normalize()}}
/**
 * 画像データ基底クラス（ラスタ画像データ抽象基盤）
 * RGBAやY（グレースケール）画像データを扱う基底クラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class u{constructor(t,e){if(this.width=1,this.height=1,this.globalAlpha=1,this.data=null,this.blend=new i(i.MODE.NONE),this.wrap=new s(s.MODE.INSIDE,this.width,this.height),this.ip=new l(l.MODE.NEAREST_NEIGHBOR),1===arguments.length){const e=t;if(!(e instanceof ImageData||e instanceof u))throw"IllegalArgumentException";this.putImageData(e)}else if(2===arguments.length){if("number"!=typeof t||"number"!=typeof e)throw"IllegalArgumentException";{const i=t,r=e;this.setSize(i,r)}}}putImageData(t){}setSize(t,e){this.width===t&&this.height===e||(this.width=t,this.height=e,this.wrap.setSize(t,e))}_copyData(t){t.blend=this.blend.clone(),t.wrap=this.wrap.clone(),t.ip=this.ip.clone(),t.setSize(this.width,this.height),t.data.set(this.data),t.globalAlpha=this.globalAlpha}clone(){const t=new u;return this._copyData(t),t}setWrapMode(t){this.wrap.setPixWrapMode(t)}getWrapMode(){return this.wrap.wrapmode}setInterpolationMode(t){this.ip.setInterpolationMode(t)}getInterpolationMode(){return this.ip.ipmode}setBlendType(t){this.blend.setBlendMode(t)}getBlendType(){return this.blend.blendmode}clear(){this.data&&this.data.fill(0)}getPixelInside(t,e){return null}setPixelInside(t,e,i){}getPixel(t,e){const i=this.wrap.getPixelPosition(t,e);return i?this.getPixelInside(i[0],i[1]):this.getPixelInside(0,0).zero()}setPixel(t,e,i){const r=this.wrap.getPixelPosition(t,e);if(r)if(this.blend.blendmode===u.MODE_BLEND.NONE)this.setPixelInside(r[0],r[1],i);else{const t=this.getPixelInside(r[0],r[1]),e=this.blend.blend(t,i,this.globalAlpha);this.setPixelInside(r[0],r[1],e)}}getColor(t,e){return this.ip.getColor(this,t,e)}getColorUV(t,e){return this.getColor(t*this.width,e*this.height)}setColor(t,e,i){this.setPixel(Math.floor(t),Math.floor(e),i)}drawPixData(t,e,i,r,n,h,s,o,l){if(!(t instanceof u))throw"IllegalArgumentException";if(3===arguments.length)h=e,s=i,o=t.width,l=t.height,e=0,i=0,r=t.width,n=t.height;else{if(5!==arguments.length)throw"IllegalArgumentException";h=e,s=i,o=r,l=n,e=0,i=0,r=t.width,n=t.height}const a=r/o,c=n/l;let g,d,p,f;for(d=i,f=s;f<s+l;f++){for(g=e,p=h;p<h+o;p++){const e=t.getColor(g,d);e&&this.setColor(p,f,e),g+=a}d+=c}}forEach(t){let e=0,i=0;for(;i<this.height;i++)for(e=0;e<this.width;e++)t(this.getPixelInside(e,i),e,i,this)}convolution(t){if(!(t instanceof a))throw"IllegalArgumentException";let e,i,r,n,h,s;const o=-(t.width>>1),l=-(t.height>>1),u=t.matrix,c=this.getPixelInside(0,0).zero(),g=this.clone();for(i=0;i<this.height;i++)for(e=0;e<this.width;e++){let a=c;for(n=i+l,s=0;s<t.height;s++,n++)for(r=e+o,h=0;h<t.width;h++,r++){const t=g.getPixel(r,n);t&&(a=a.addColor(t.mul(u[s][h])))}this.setPixelInside(e,i,a)}}convolutionBilateral(e,i){if(!(e instanceof a))throw"IllegalArgumentException";let r,n,h,s,o,l;void 0===i&&(i=.8);const u=-(e.width>>1),c=-(e.height>>1),g=e.matrix,d=this.getPixelInside(0,0).zero(),p=this.clone(),f=.01*-(1-i)-.001,w=[];for(r=0;r<768;r++)w[r]=Math.exp(r*r*f);for(n=0;n<this.height;n++)for(r=0;r<this.width;r++){const i=p.getPixel(r,n),a=i.getBlendAlpha();let f=0,M=d;for(s=n+c,l=0;l<e.height;l++,s++)for(h=r+u,o=0;o<e.width;o++,h++){const e=p.getPixel(h,s);if(!e)continue;const r=w[Math.floor(e.normColor(i,t.NORM_MODE.EUGRID))]*g[l][o];M=M.addColor(e.mul(r)),f+=r}M=M.div(f).setBlendAlpha(a),this.setPixelInside(r,n,M)}}convolutionExp(t,e){if(!(t instanceof a))throw"IllegalArgumentException";let i,r,n,h,s,o;void 0===e&&(e=1.2);const l=-(t.width>>1),u=-(t.height>>1),c=t.matrix,g=this.getPixelInside(0,0).zero(),d=this.clone(),p=[];for(i=0;i<256;i++)p[i]=Math.pow(e,i);for(r=0;r<this.height;r++)for(i=0;i<this.width;i++){let a=g;for(h=r+u,o=0;o<t.height;o++,h++)for(n=i+l,s=0;s<t.width;s++,n++){const t=d.getPixel(n,h);t&&(a=a.addColor(t.table(p).mul(c[o][s])))}this.setPixelInside(i,r,a.baselog(e))}}convolutionUnSharp(t,e){if(!(t instanceof a))throw"IllegalArgumentException";let i,r,n,h,s,o;const l=-(t.width>>1),u=-(t.height>>1),c=t.matrix,g=this.getPixelInside(0,0).zero(),d=this.clone();for(r=0;r<this.height;r++)for(i=0;i<this.width;i++){let a=g;for(h=r+u,o=0;o<t.height;o++,h++)for(n=i+l,s=0;s<t.width;s++,n++){const t=d.getPixel(n,h);t&&(a=a.addColor(t.mul(c[o][s])))}const p=d.getPixel(i,r),f=p.subColor(a).mul(e);this.setPixelInside(i,r,p.addColor(f))}}filterSharp(t){const e=a.makeSharpenFilter(t);this.convolution(e)}filterBlur(t){let e;e=a.makeBlur(t,1),this.convolution(e),e=a.makeBlur(1,t),this.convolution(e)}filterGaussian(t){let e;e=a.makeGaussianFilter(t,1),this.convolution(e),e=a.makeGaussianFilter(1,t),this.convolution(e)}filterUnSharp(t,e){const i=a.makeGaussianFilter(t,t);this.convolutionUnSharp(i,e)}filterBilateral(t,e){const i=a.makeGaussianFilter(t,t);this.convolutionBilateral(i,e)}filterSoftLens(t,e){const i=a.makeCircle(t);this.convolutionExp(i,e)}}u.MODE_WRAP=s.MODE,u.MODE_IP=l.MODE,u.MODE_BLEND=i.MODE;
/**
 * RGBA色（Red, Green, Blue, Alpha）を扱う色クラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
class c extends t{constructor(t){super(),this.rgba=[t[0],t[1],t[2],t[3]]}get r(){return this.rgba[0]}get g(){return this.rgba[1]}get b(){return this.rgba[2]}get a(){return this.rgba[3]}getColor(){return this.rgba}clone(){return new c(this.rgba)}zero(){return new c([0,0,0,0])}one(){return new c([1,1,1,1])}add(t){return new c([this.r+t,this.g+t,this.b+t,this.a+t])}sub(t){return new c([this.r-t,this.g-t,this.b-t,this.a-t])}mul(t){return new c([this.r*t,this.g*t,this.b*t,this.a*t])}div(t){return new c([this.r/t,this.g/t,this.b/t,this.a/t])}exp(){return new c([Math.exp(this.r),Math.exp(this.g),Math.exp(this.b),Math.exp(this.a)])}log(){return new c([Math.log(this.r),Math.log(this.g),Math.log(this.b),Math.log(this.a)])}pow(t){return new c([Math.pow(t,this.r),Math.pow(t,this.g),Math.pow(t,this.b),Math.pow(t,this.a)])}baselog(t){const e=1/Math.log(t);return new c([Math.log(this.r)*e,Math.log(this.g)*e,Math.log(this.b)*e,Math.log(this.a)*e])}table(t){return new c([t[Math.round(this.r)],t[Math.round(this.g)],t[Math.round(this.b)],t[Math.round(this.a)]])}random(){return new c([Math.floor(256*Math.random()),Math.floor(256*Math.random()),Math.floor(256*Math.random()),Math.floor(256*Math.random())])}luminance(){return.2126*this.r+.7152*this.g+.0722*this.b}addColor(t){return new c([this.r+t.r,this.g+t.g,this.b+t.b,this.a+t.a])}subColor(t){return new c([this.r-t.r,this.g-t.g,this.b-t.b,this.a-t.a])}mulColor(t){return new c([this.r*t.r,this.g*t.g,this.b*t.b,this.a*t.a])}divColor(t){return new c([this.r/t.r,this.g/t.g,this.b/t.b,this.a/t.a])}maxColor(t){return new c([Math.max(t.r,this.r),Math.max(t.g,this.g),Math.max(t.b,this.b),Math.max(t.a,this.a)])}minColor(t){return new c([Math.min(t.r,this.r),Math.min(t.g,this.g),Math.min(t.b,this.b),Math.min(t.a,this.a)])}norm(e){return e===t.NORM_MODE.MANHATTEN?(Math.abs(this.r)+Math.abs(this.g)+Math.abs(this.b))/3:e===t.NORM_MODE.EUGRID?Math.sqrt(this.r*this.r+this.g*this.g+this.b*this.b)/3:void 0}normFast(e){return e===t.NORM_MODE.MANHATTEN?Math.abs(this.r)+Math.abs(this.g)+Math.abs(this.b):e===t.NORM_MODE.EUGRID?this.r*this.r+this.g*this.g+this.b*this.b:void 0}getBlendAlpha(){return this.a/255}setBlendAlpha(t){const e=this.clone();return e.rgba[3]=255*t,e}exchangeColorAlpha(t){return new c([this.r,this.g,this.b,t.a])}getRRGGBB(){return this.r<<16|this.g<<8|255&this.b}getRed(){return this.r}getGreen(){return this.g}getBlue(){return this.b}equals(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}toString(){return"color("+this.r+","+this.g+","+this.b+","+this.a+")"}mulMatrix(t){return new c([this.r*t[0][0]+this.g*t[0][1]+this.b*t[0][2]+this.a*t[0][3],this.r*t[1][0]+this.g*t[1][1]+this.b*t[1][2]+this.a*t[1][3],this.r*t[2][0]+this.g*t[2][1]+this.b*t[2][2]+this.a*t[2][3],this.r*t[3][0]+this.g*t[3][1]+this.b*t[3][2]+this.a*t[3][3]])}}
/**
 * 輝度（Y成分・グレースケール）のみを扱う色クラス
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class g extends t{constructor(t){super(),this.y=t}getColor(){return this.y}clone(){return new g(this.y)}zero(){return new g(0)}one(){return new g(1)}add(t){return new g(this.y+t)}sub(t){return new g(this.y-t)}mul(t){return new g(this.y*t)}div(t){return new g(this.y/t)}exp(){return new g(Math.exp(this.y))}log(){return new g(Math.log(this.y))}pow(t){return new g(Math.pow(t,this.y))}baselog(t){return new g(Math.log(this.y)/Math.log(t))}table(t){return new g(t[Math.floor(this.y)])}random(){return new g(256*Math.random())}luminance(){return this.y}addColor(t){return new g(this.y+t.y)}subColor(t){return new g(this.y-t.y)}mulColor(t){return new g(this.y*t.y)}divColor(t){return new g(this.y/t.y)}maxColor(t){return new g(Math.max(t.y,this.y))}minColor(t){return new g(Math.min(t.y,this.y))}norm(){return Math.abs(this.y)}normFast(){return Math.abs(this.y)}getBlendAlpha(){return 1}setBlendAlpha(){return this}exchangeColorAlpha(){return this}equals(t){return this.y===t.y}toString(){return"color("+this.y+")"}}
/**
 * 3次元ベクトルクラス
 * 画像処理やノーマルマップでの方向ベクトル表現等に利用します
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class d{constructor(t,e,i){this.x=t,this.y=e,this.z=i}cross(t){return new d(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}getDirection(t){return new d(t.x-this.x,t.y-this.y,t.z-this.z)}normalize(){let t=this.x*this.x+this.y*this.y+this.z*this.z;return t=Math.sqrt(1/t),new d(this.x*t,this.y*t,this.z*t)}getNormalMapColor(){return new c([Math.round(127.5*(1+this.x)),Math.round(127.5*(1-this.y)),Math.round(127.5*(1+this.z)),255])}static createNormalVector(t){if(!(t instanceof c))throw"not PixColorRGBA";return new d(t.r/128-1,-t.g/128+1,t.b/128-1)}}
/**
 * グレースケール画像データクラス（輝度Yのみで管理）
 * 1チャンネル（Y）の画像データ処理を提供
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class p extends u{constructor(t,e){1===arguments.length?super(t):2===arguments.length?super(t,e):super()}clone(){const t=new p(this.width,this.height);return this._copyData(t),t}setSize(t,e){super.setSize(t,e),this.data=new Float32Array(this.width*this.height)}getPixelInside(t,e){const i=e*this.width+t;return new g(this.data[i])}setPixelInside(t,e,i){const r=e*this.width+t;this.data[r]=i.getColor()}setPixel(t,e,i){super.setPixel(t,e,i)}getColor(t,e){return super.getColor(t,e)}getColorUV(t,e){return super.getColorUV(t,e)}setColor(t,e,i){super.setPixel(t,e,i)}forEach(t){super.forEach(t)}putImageData(t,e){if(t instanceof ImageData||t instanceof f){this.setSize(t.width,t.height),void 0===e&&(e=0);let i=0;for(let r=0;r<this.data.length;r++)this.data[r]=t.data[i+e],i+=4}else{if(!(t instanceof p))throw"IllegalArgumentException";this.setSize(t.width,t.height),this.data.set(t.data)}}putImageDataR(t){this.putImageData(t,0)}putImageDataG(t){this.putImageData(t,1)}putImageDataB(t){this.putImageData(t,2)}putImageDataA(t){this.putImageData(t,3)}getImageData(){const t=document.createElement("canvas");t.width=this.width,t.height=this.height;const e=t.getContext("2d").getImageData(0,0,t.width,t.height);let i=0,r=0;for(;r<this.data.length;r++){const t=Math.floor(this.data[r]);e.data[i+0]=t,e.data[i+1]=t,e.data[i+2]=t,e.data[i+3]=255,i+=4}return e}getNormalMap(){if(this.getWrapMode()===u.MODE_WRAP.INSIDE)throw"not inside";const t=new f(this.width,this.height);let e,i;for(i=0;i<this.height;i++)for(e=0;e<this.width;e++){const r=new d(e-1,i,this.getPixel(e-1,i).getColor()),n=new d(e+1,i,this.getPixel(e+1,i).getColor()),h=r.getDirection(n),s=new d(e,i-1,this.getPixel(e,i-1).getColor()),o=new d(e,i+1,this.getPixel(e,i+1).getColor()),l=s.getDirection(o),a=h.cross(l).normalize();t.setPixelInside(e,i,a.getNormalMapColor())}return t}filterEnvironmentMapping(t){return null}}
/**
 * RGBAカラー画像データクラス（4チャンネル画像データ）
 * 32bit整数(0xRRGGBBAA)の画素配列で管理。各種チャンネル処理や減色などもサポート
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */class f extends u{constructor(t,e){1===arguments.length?super(t):2===arguments.length?super(t,e):super()}clone(){const t=new f(this.width,this.height);return this._copyData(t),t}setSize(t,e){super.setSize(t,e),this.data=new Uint8ClampedArray(this.width*this.height*4)}getPixelInside(t,e){const i=4*(e*this.width+t);return new c([this.data[i],this.data[i+1],this.data[i+2],this.data[i+3]])}setPixelInside(t,e,i){const r=4*(e*this.width+t);this.data[r]=i.getColor()[0],this.data[r+1]=i.getColor()[1],this.data[r+2]=i.getColor()[2],this.data[r+3]=i.getColor()[3]}setPixel(t,e,i){super.setPixel(t,e,i)}getColor(t,e){return super.getColor(t,e)}getColorUV(t,e){return super.getColorUV(t,e)}setColor(t,e,i){super.setPixel(t,e,i)}forEach(t){super.forEach(t)}putDataY(t,e){if(!(t instanceof p))throw"IllegalArgumentException";this.setSize(t.width,t.height),void 0===e&&(e=0);let i=0,r=0;for(;r<t.data.length;r++)this.data[i+e]=Math.floor(t.data[r]),i+=4}putDataYToR(t){this.putDataY(t,0)}putDataYToG(t){this.putDataY(t,1)}putDataYToB(t){this.putDataY(t,2)}putDataYToA(t){this.putDataY(t,3)}putImageData(t){if(t instanceof ImageData||t instanceof f)this.setSize(t.width,t.height),this.data.set(t.data);else{if(!(t instanceof p))throw"IllegalArgumentException";this.putImageData(t.getImageData())}}getImageData(){const t=document.createElement("canvas");t.width=this.width,t.height=this.height;const e=t.getContext("2d").getImageData(0,0,t.width,t.height);return e.data.set(this.data),e}grayscale(){this.forEach((function(t,e,i,r){const n=~~t.luminance(),h=new c([n,n,n,t.rgba[3]]);r.setPixelInside(e,i,h)}))}getColorCount(){const t=new Uint8ClampedArray(2097152);let e=0;return this.forEach((function(i){const r=i.getRRGGBB(),n=r>>3,h=r%7;t[n]>>h&1||(e++,t[n]=255&(t[n]^1<<h))})),e}getPalletMedianCut(t){if(this.getColorCount()<=t)return null;let e,i,r,n;const h=new Uint32Array(2097152);let s=0;const o=[],l=[[],[],[]],a=[[],[],[]];for(o[0]=this.width*this.height,e=0;e<3;e++)a[e][s]=0,l[e][s]=127;let u,g,d,p,f,w,M;for(this.forEach((function(t){h[function(t){return t.getRed()>>1<<14|t.getGreen()>>1<<7|t.getBlue()>>1}(t)]++})),s++,M=1;s<t;){let t=0,c=0;for(e=0;e<M;e++){u=l[0][e]-a[0][e],g=l[1][e]-a[1][e],d=l[2][e]-a[2][e];const i=u*g*d;t<i&&(t=i,p=u,f=g,w=d,c=e)}let m=f,x=1;if(m<p&&(m=p,x=0),m<w&&(m=w,x=2),0===m)break;{const t=a[x][c]+(m>>1);for(t===l[x][c]?(a[x][M]=t,l[x][M]=l[x][c],l[x][c]=t-1):(a[x][M]=t+1,l[x][M]=l[x][c],l[x][c]=t),e=0;e<3;e++)e!==x&&(a[e][M]=a[e][c],l[e][M]=l[e][c])}for(o[M]=0,i=a[0][M];i<=l[0][M];i++)for(r=a[1][M];r<=l[1][M];r++)for(n=a[2][M];n<=l[2][M];n++)o[M]+=h[i<<14|r<<7|n];if(o[c]-=o[M],0===o[c])for(o[c]=o[M],e=0;e<3;e++)a[e][c]=a[e][M],l[e][c]=l[e][M];else M++,s++}const m=[];for(e=0;e<s;e++){let t=0,s=0,u=0;for(i=a[0][e];i<=l[0][e];i++)for(r=a[1][e];r<=l[1][e];r++)for(n=a[2][e];n<=l[2][e];n++){const e=h[i<<14|r<<7|n];t+=e*(i<<1),s+=e*(r<<1),u+=e*(n<<1)}i=Math.round(t/o[e]),r=Math.round(s/o[e]),n=Math.round(u/o[e]),i=i<0?0:i>255?255:i,r=r<0?0:r>255?255:r,n=n<0?0:n>255?255:n,m[e]=new c([i,r,n,255])}return m}getPallet(){const t=[],e=new Uint32Array(256);let i=0,r=0;return this.forEach((function(n){if(i>255)return;const h=n.getRRGGBB();for(r=0;r<i;r++)if(e[r]===h)return;e[i]=h,t[i]=n,i++})),t}getPalletGrayscale(t){const e=t<2?2:t>256?256:t,i=[],r=255/(e-1);let n,h=0;for(n=0;n<e;n++){let t=Math.round(h);t=t<0?0:t>255?255:t,i[n]=new c([t,t,t,255]),h+=r}return i}quantizationSimple(e){this.forEach((function(i,r,n,h){const s=i.searchColor(e,t.NORM_MODE.EUGRID);h.setPixelInside(r,n,s.c1.color.exchangeColorAlpha(i))}))}quantizationOrdered(t,e,i){this.forEach((function(r,n,h,s){const o=r.searchColor(t,i),l=o.c1.color,a=o.c1.norm,u=o.c2.color,c=o.c2.norm;let g=a+c,d=0;g=0===g?1:g;const p=e.pattern[h%e.height][n%e.width];let f=null;l.luminance>u.luminance?(d=Math.floor(c*e.maxnumber/g),f=p<=d?l.exchangeColorAlpha(r):u.exchangeColorAlpha(r)):(d=Math.floor(a*e.maxnumber/g),f=p>=d?l.exchangeColorAlpha(r):u.exchangeColorAlpha(r)),s.setPixelInside(n,h,f)}))}quantizationDiffusion(e,i){const r=this.width*this.height,n=new Int16Array(r),h=new Int16Array(r),s=new Int16Array(r);let o=0;this.forEach((function(t,e,i,r){o=i*r.width+e,n[o]=t.getRed(),h[o]=t.getGreen(),s[o]=t.getBlue()}));const l=this.width-i.width+i.center;let a,u,g=0;for(u=0;u<i.height;u++)for(a=0;a<i.width;a++)g+=i.pattern[u][a];const d=[];for(u=0;u<i.height;u++)for(d[u]=[],a=0;a<i.width;a++)d[u][a]=i.pattern[u][a]/g;this.forEach((function(r,g,p,f){o=p*f.width+g;const w=new c([n[o],h[o],s[o],255]),M=w.searchColor(e,t.NORM_MODE.EUGRID).c1.color;if(f.setPixelInside(g,p,M.exchangeColorAlpha(r)),g>l)return;const m=w.subColor(M);for(u=0;u<i.height;u++)for(a=0===u?i.center:0;a<i.width;a++){const t=g+a-i.center,e=p+u;if(t<0||e>=f.height)continue;const r=e*f.width+t;n[r]+=m.getRed()*d[u][a],h[r]+=m.getGreen()*d[u][a],s[r]+=m.getBlue()*d[u][a]}}))}filterQuantizationSimple(t){if(this.getColorCount()>t){const e=this.getPalletMedianCut(t);this.quantizationSimple(e)}}filterQuantizationOrdered(e,i){void 0===i&&(i=t.NORM_MODE.EUGRID);if(this.getColorCount()>e){const t=this.getPalletMedianCut(e);this.quantizationOrdered(t,f.quantization.orderPattern.patternBayer,i)}}filterQuantizationDiffusion(t,e){void 0===e&&(e=f.quantization.diffusionPattern.patternFloydSteinberg);if(this.getColorCount()>t){const i=this.getPalletMedianCut(t);this.quantizationDiffusion(i,e)}}}f.quantization={diffusionPattern:{patternFloydSteinberg:{width:3,height:2,center:1,pattern:[[0,0,7],[3,5,1]]},patternJarvisJudiceNinke:{width:5,height:3,center:2,pattern:[[0,0,0,7,5],[3,5,7,5,3],[1,3,5,3,1]]}},orderPattern:{patternBayer:{width:4,height:4,maxnumber:16,pattern:[[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]]}}};
/**
 * PixFX
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */
const w={PixDataRGBA:f,PixColorRGBA:c,PixDataY:p,PixColorY:g,MODE_WRAP:u.MODE_WRAP,MODE_IP:u.MODE_IP,MODE_BLEND:u.MODE_BLEND};module.exports=w;

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>data/PixDataY.js - InputDetect</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <script src="scripts/commonNav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
</nav>

<div id="main">
    
    <h1 class="page-title">data/PixDataY.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>﻿/**
 * グレースケール画像データクラス（輝度Yのみで管理）
 * 1チャンネル（Y）の画像データ処理を提供
 *
 * @module PixFX
 * @author natade (https://github.com/natade-jp)
 * @license MIT
 */

import PixColorY from "../color/PixColorY.js";
import PixData from "./PixData.js";
import PixDataRGBA from "./PixDataRGBA.js";
import PixVector from "../color/PixVector.js";

export default class PixDataY extends PixData {
	/**
	 * 初期化
	 * @constructor
	 * @param {ImageData|PixDataRGBA|PixDataY|number} [arg1] 元画像または幅
	 * @param {number} [arg2] 高さ
	 */
	constructor(arg1, arg2) {
		if (arguments.length === 1) {
			super(arg1);
		} else if (arguments.length === 2) {
			super(arg1, arg2);
		} else {
			super();
		}
	}

	/**
	 * この画像データのクローンを作成
	 * @returns {PixDataY}
	 */
	clone() {
		const x = new PixDataY(this.width, this.height);
		this._copyData(x);
		return x;
	}

	/**
	 * サイズを変更（内容は初期化）
	 * @param {number} width
	 * @param {number} height
	 */
	setSize(width, height) {
		super.setSize(width, height);
		this.data = new Float32Array(this.width * this.height);
	}

	/**
	 * 範囲内座標のY値を取得
	 * @param {number} x
	 * @param {number} y
	 * @returns {PixColorY}
	 */
	getPixelInside(x, y) {
		const p = y * this.width + x;
		return new PixColorY(this.data[p]);
	}

	/**
	 * 範囲内座標のY値を設定
	 * @param {number} x
	 * @param {number} y
	 * @param {PixColorY} color
	 */
	setPixelInside(x, y, color) {
		const p = y * this.width + x;
		this.data[p] = color.getColor();
	}

	/**
	 * 任意座標(x, y)に画素値をセット（範囲外もラッピングモードに応じて書き込み）
	 * @param {number} x
	 * @param {number} y
	 * @param {PixColorY} color
	 */
	setPixel(x, y, color) {
		super.setPixel(x, y, color);
	}

	/**
	 * 実数座標(x, y)の補間色を返す
	 * @param {number} x
	 * @param {number} y
	 * @returns {PixColorY}
	 */
	getColor(x, y) {
		// @ts-ignore
		return super.getColor(x, y);
	}

	/**
	 * UV座標（0～1）でテクスチャとして色取得
	 * @param {number} u
	 * @param {number} v
	 * @returns {PixColorY}
	 */
	getColorUV(u, v) {
		// @ts-ignore
		return super.getColorUV(u, v);
	}

	/**
	 * 実数座標(x, y)に画素値をセット（切り捨て座標に書き込み）
	 * @param {number} x
	 * @param {number} y
	 * @param {PixColorY} color
	 */
	setColor(x, y, color) {
		super.setPixel(x, y, color);
	}

	/**
	 * 全画素に対してコールバック関数を適用
	 * @param {function(PixColorY, number, number, PixData):void} callback (color, x, y, this)
	 */
	forEach(callback) {
		super.forEach(callback);
	}

	/**
	 * 各種画像データから本クラスへ変換して格納
	 * @param {ImageData|PixDataRGBA|PixDataY} imagedata
	 * @param {number} [n=0] RGBAのどのチャンネルか（0:R, 1:G, 2:B, 3:A）
	 */
	putImageData(imagedata, n) {
		if (imagedata instanceof ImageData || imagedata instanceof PixDataRGBA) {
			this.setSize(imagedata.width, imagedata.height);
			if (n === undefined) {
				n = 0;
			}
			let p = 0;
			for (let i = 0; i &lt; this.data.length; i++) {
				this.data[i] = imagedata.data[p + n];
				p += 4;
			}
		} else if (imagedata instanceof PixDataY) {
			this.setSize(imagedata.width, imagedata.height);
			this.data.set(imagedata.data);
		} else {
			throw "IllegalArgumentException";
		}
	}

	/**
	 * RGBA画像からR成分のみ取り込む
	 * @param {ImageData|PixDataRGBA} imagedata
	 */
	putImageDataR(imagedata) {
		this.putImageData(imagedata, 0);
	}

	/**
	 * RGBA画像からG成分のみ取り込む
	 * @param {ImageData|PixDataRGBA} imagedata
	 */
	putImageDataG(imagedata) {
		this.putImageData(imagedata, 1);
	}

	/**
	 * RGBA画像からB成分のみ取り込む
	 * @param {ImageData|PixDataRGBA} imagedata
	 */
	putImageDataB(imagedata) {
		this.putImageData(imagedata, 2);
	}

	/**
	 * RGBA画像からA成分のみ取り込む
	 * @param {ImageData|PixDataRGBA} imagedata
	 */
	putImageDataA(imagedata) {
		this.putImageData(imagedata, 3);
	}

	/**
	 * ImageData（RGBA, Canvas API）形式で出力
	 * @returns {ImageData}
	 */
	getImageData() {
		const canvas = document.createElement("canvas");
		canvas.width = this.width;
		canvas.height = this.height;
		const context = canvas.getContext("2d");
		const imagedata = context.getImageData(0, 0, canvas.width, canvas.height);
		let p = 0,
			i = 0;
		for (; i &lt; this.data.length; i++) {
			const x = Math.floor(this.data[i]);
			imagedata.data[p + 0] = x;
			imagedata.data[p + 1] = x;
			imagedata.data[p + 2] = x;
			imagedata.data[p + 3] = 255;
			p += 4;
		}
		return imagedata;
	}

	/**
	 * このグレースケール画像からノーマルマップを生成
	 * @returns {PixDataRGBA}
	 * @throws {Error} ラッピングモードがINSIDEの場合は例外
	 */
	getNormalMap() {
		if (this.getWrapMode() === PixData.MODE_WRAP.INSIDE) {
			// 端の値を取得できないのでエラー
			throw "not inside";
		}

		const output = new PixDataRGBA(this.width, this.height);
		let x, y;
		for (y = 0; y &lt; this.height; y++) {
			for (x = 0; x &lt; this.width; x++) {
				const x1 = new PixVector(x - 1, y, this.getPixel(x - 1, y).getColor());
				const x2 = new PixVector(x + 1, y, this.getPixel(x + 1, y).getColor());
				const x3 = x1.getDirection(x2);
				const y1 = new PixVector(x, y - 1, this.getPixel(x, y - 1).getColor());
				const y2 = new PixVector(x, y + 1, this.getPixel(x, y + 1).getColor());
				const y3 = y1.getDirection(y2);
				const n = x3.cross(y3).normalize();
				output.setPixelInside(x, y, n.getNormalMapColor());
			}
		}
		return output;
	}

	/**
	 * ノーマルマップを環境マッピングする（未実装）
	 * @param {PixDataRGBA} texture
	 * @returns {PixDataRGBA}
	 */
	filterEnvironmentMapping(texture) {
		return null;
	}
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
